

alias functionNum R1;
alias currentPID R2;


// ---------------------------------


if(functionNum == 3) then

    // call resource manager by convention
    multipush(R1, R2, R3);
    R1 = 8;
    R2 = currentPID;
    call RESOURCE_MANAGER;
    multipop(R1, R2, R3);

    // print when resource manager returns
    print R3;

    // releasing terminal
    multipush(R1, R2, R3);
    R1 = 9;
    R2 = currentPID;
    call RESOURCE_MANAGER;
    multipop(R1, R2, R3);

    return;

endif;


// ---------------------------------


if(functionNum == 4) then

    // call resource manager by convention
    multipush(R1, R2, R3);
    R1 = 8;
    R2 = currentPID;
    call RESOURCE_MANAGER;
    multipop(R1, R2, R3);

    // input from terminal
    read;

    // sleep the process and call scheduler
    [PROCESS_TABLE + (currentPID*16) + 4] = WAIT_TERMINAL;
    multipush(R1, R2, R3);
    call SCHEDULER;
    multipop(R1, R2, R3);
    
    // move input from process table buffer to address
    alias readAddr R4;
    readAddr = [PTBR + (2 * (R3/512))]*512 + (R3 % 512);
    [readAddr] = [PROCESS_TABLE + (16*currentPID) + 8];

    return;

endif;


// ---------------------------------


if(functionNum == DISK_LOAD) then

    // acquire the disk
    multipush(R1, R2, R3, R4);
    R1 = ACQUIRE_DISK;
    R2 = [SYSTEM_STATUS_TABLE + 1];
    call RESOURCE_MANAGER;
    multipop(R1, R2, R3, R4);

    // set disk status table entries
    [DISK_STATUS_TABLE + 0] = 0;
    [DISK_STATUS_TABLE + 1] = DISK_LOAD;
    [DISK_STATUS_TABLE + 2] = R3;
    [DISK_STATUS_TABLE + 3] = R4;
    [DISK_STATUS_TABLE + 4] = currentPID;

    // asynchronous load
    load(R3, R4);

    [PROCESS_TABLE + (16*currentPID) + 4] = WAIT_DISK;
    multipush(R1, R2, R3, R4);
    call SCHEDULER;
    multipop(R1, R2, R3, R4);

    return;
endif;


// ---------------------------------


halt;