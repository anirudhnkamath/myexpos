
// mode flag
[PROCESS_TABLE + (16*[SYSTEM_STATUS_TABLE+1]) + 9] = INT_FORK;

alias userSP R1;
userSP = SP;

// switch to kernel stack
[PROCESS_TABLE + ( [SYSTEM_STATUS_TABLE + 1] * 16) + 13] = SP;
SP = [PROCESS_TABLE + ([SYSTEM_STATUS_TABLE + 1] * 16) + 11] * 512 - 1;


// ---------------------------------


// get free pid
multipush(R1);
R1 = GET_PCB_ENTRY;
call PROCESS_MANAGER;
multipop(R1);

// if full
if(R0 == -1) then
    // return -1 and reset mode flag
    [([PTBR + (((userSP-1)/512) * 2)] * 512) + ((userSP-1)%512)] = -1;
    [PROCESS_TABLE + (16*[SYSTEM_STATUS_TABLE]) + 9] = INT_FORK;
    SP = userSP;
    ireturn;
endif;

alias childPID R2;
childPID = R0;


// ---------------------------------


// allocate parent heap if its not done
if([PTBR + 4] == -1 || [PTBR + 6] == -1) then
    alias i R3;
    i = 4;
    while(i < 8) do
        multipush(R1, R2, R3);
        R1 = GET_FREE_PAGE;
        call MEMORY_MANAGER;
        multipop(R1, R2, R3);

        [PTBR + i] = R0;
        [PTBR + i+1] = "0110";
        i = i + 2;
    endwhile;
endif;


// ---------------------------------


// process table values for child

// userid
[PROCESS_TABLE + (16*childPID) + 3] = [PROCESS_TABLE + (16*[SYSTEM_STATUS_TABLE+1]) + 3];
// swap
[PROCESS_TABLE + (16*childPID) + 6] = [PROCESS_TABLE + (16*[SYSTEM_STATUS_TABLE+1]) + 6];
// user area swap
[PROCESS_TABLE + (16*childPID) + 10] = [PROCESS_TABLE + (16*[SYSTEM_STATUS_TABLE+1]) + 10];
// inode index
[PROCESS_TABLE + (16*childPID) + 7] = [PROCESS_TABLE + (16*[SYSTEM_STATUS_TABLE+1]) + 7];
// uptr
[PROCESS_TABLE + (16*childPID) + 13] = [PROCESS_TABLE + (16*[SYSTEM_STATUS_TABLE+1]) + 13];

// mode
[PROCESS_TABLE + (16*childPID) + 9] = 0;
// kptr
[PROCESS_TABLE + (16*childPID) + 12] = 0;
// tick
[PROCESS_TABLE + (16*childPID) + 0] = 0;

// ppid
[PROCESS_TABLE + (16*childPID) + 2] = [SYSTEM_STATUS_TABLE + 1];

// state
[PROCESS_TABLE + (16*childPID) + 4] = CREATED;

// get new page for user area
multipush(R1, R2, R3);
R1 = GET_FREE_PAGE;
call MEMORY_MANAGER;
multipop(R1, R2, R3);
[PROCESS_TABLE + (16*childPID) + 11] = R0;


// ---------------------------------


// copy the per process resource table

alias childPPTable R4;
childPPTable = [PROCESS_TABLE + (16*childPID) + 11]*512 + RESOURCE_TABLE_OFFSET;
alias parentPPTable R5;
parentPPTable = [PROCESS_TABLE + (16*[SYSTEM_STATUS_TABLE+1]) + 11]*512 + RESOURCE_TABLE_OFFSET;

// iterate and copy
alias i R6;
i = 0;
while(i < 16) do
    [childPPTable + i] = [parentPPTable + i];
    i = i + 1;
endwhile;


// ---------------------------------


// copy the disk map table
i = 0;
while(i < 10) do
    [DISK_MAP_TABLE + (10*childPID) + i] = [DISK_MAP_TABLE + (10*[SYSTEM_STATUS_TABLE+1]) + i];
    i = i + 1;
endwhile;


// ---------------------------------


// set up page table for child
alias childPTBR R4;
childPTBR = PAGE_TABLE_BASE + (20*childPID);

// lib, heap, code same as parent
i = 0;
while(i < 16) do
    [childPTBR + i] = [PTBR + i];
    [childPTBR + i+1] = [PTBR + i+1];

    [MEMORY_FREE_LIST + [childPTBR+i]] = [MEMORY_FREE_LIST + [childPTBR+i]] + 1;
    i = i + 2;
endwhile;

// new pages for stack
i = 16;
while(i < 20) do
    multipush(R1, R2, R3, R4, R5, R6);
    R1 = GET_FREE_PAGE;
    call MEMORY_MANAGER;
    multipop(R1, R2, R3, R4, R5, R6);

    [childPTBR + i] = R0;
    [childPTBR + i+1] = "0110";
    i = i + 2;
endwhile;


// ---------------------------------


// copy parent stack to child
alias parentStack R6;
alias childStack R7;

parentStack = [PTBR + 16];
childStack = [childPTBR + 16];
i = 0;
while(i < 512) do
    [childStack*512 + i] = [parentStack*512 + i];
    i = i + 1;
endwhile;

parentStack = [PTBR + 18];
childStack = [childPTBR + 18];
i = 0;
while(i < 512) do
    [childStack*512 + i] = [parentStack*512 + i];
    i = i + 1;
endwhile;


// ---------------------------------


// store bp to kernel stk of child
[PROCESS_TABLE + (16*childPID) + 11]*512 = BP;


// ---------------------------------


// store return values
[[PTBR + (2 * ((userSP-1)/512))] * 512 + ((userSP-1) % 512)] = childPID;
[[childPTBR + (2 * ((userSP-1)/512))] * 512 + ((userSP-1) % 512)] = 0;


// ---------------------------------


// reset mode flag
[PROCESS_TABLE + (16*[SYSTEM_STATUS_TABLE+1]) + 9] = 0;

// switch to user stack
SP = userSP;


// ---------------------------------


ireturn;